Package names

The language module should contain basic settings for source segmentation.
In Java this means the following levels (and package prefixes):
 - API
 - Unit
 - Module
 - Boot
 
They are separated by their lifecycle. The API comes from the Language resource,
never regenerated, affected by the prefix only; all the sources depend on it.
The Unit is generated from the Unit object content, regenerated anytime the Unit
declaration changes. The Module is an external source, generated only for new
Logic objects (or regenerated on "reset", extended on message changes - these
helper functions come far later). The Boot is generated by the language module 
following the settings and templates in the Build object.

API
I should not let "new" operations out. The Util should contain a BootAPI that has
no instance repository, but can serve Variant, VariantStructure, etc. as the API
declares. During the boot process, this BootAPI is replaced with the kernel's real
API and works in this way on.
The requests for the storage objects allows having a memory management on even Variant
and Aspect level. Cons: the user can reuse the requested Variant multiple times.
Here may come a "smart pointer" approach: as long as the value is the same, several
Aspects may refer to the same Variant instance that has a reference counter. When it
is updated, and the refCnt is not 1, the Variant is cloned (with refCnt=1), then 
gets updated.

Booting
There are many things that the Build must contain. First, the Language, that brings
the API sources in for example C or Java6 (and does the compilation, etc).
Then, the running environment with the "main" function and the generated deployment
settings.
The module handler. The Application may be monolithic, all compiled into one jar/exe,
no module binary loader, the kernel initialization is called directly; or modular,
when there is a Boot component and a binary loader, also related to the Language,
that provides the temporal API functionality along the boot process, and handles the
module loading according to the settings (maybe an URLClassLoader, but it can also be
a remote loader from a database or whatever...). Thus, the binary loader must reside
outside any module, as a "toolkit", but accessible only for the boot process and the 
kernel...