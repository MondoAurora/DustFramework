Package names

The language module should contain basic settings for source segmentation.
In Java this means the following levels (and package prefixes):
 - API
 - Unit
 - Module
 - Boot
 
They are separated by their lifecycle. The API comes from the Language resource,
never regenerated, affected by the prefix only; all the sources depend on it.
The Unit is generated from the Unit object content, regenerated anytime the Unit
declaration changes. The Module is an external source, generated only for new
Logic objects (or regenerated on "reset", extended on message changes - these
helper functions come far later). The Boot is generated by the language module 
following the settings and templates in the Build object.

API
I should not let "new" operations out. The Util should contain a BootAPI that has
no instance repository, but can serve Variant, VariantStructure, etc. as the API
declares. During the boot process, this BootAPI is replaced with the kernel's real
API and works in this way on.
The requests for the storage objects allows having a memory management on even Variant
and Aspect level. Cons: the user can reuse the requested Variant multiple times.
Here may come a "smart pointer" approach: as long as the value is the same, several
Aspects may refer to the same Variant instance that has a reference counter. When it
is updated, and the refCnt is not 1, the Variant is cloned (with refCnt=1), then 
gets updated.

Booting
There are many things that the Build must contain. First, the Language, that brings
the API sources in for example C or Java6 (and does the compilation, etc).
Then, the running environment with the "main" function and the generated deployment
settings.
The module handler. The Application may be monolithic, all compiled into one jar/exe,
no module binary loader, the kernel initialization is called directly; or modular,
when there is a Boot component and a binary loader, also related to the Language,
that provides the temporal API functionality along the boot process, and handles the
module loading according to the settings (maybe an URLClassLoader, but it can also be
a remote loader from a database or whatever...). Thus, the binary loader must reside
outside any module, as a "toolkit", but accessible only for the boot process and the 
kernel...

Message
Going forward along the generated codes, it would be possible to generate normal Java
classes. However, in Java I have a built-in RTTI which is not always available, so I
can't rely on it in other languages. Any 'solution' would let the coder some 'cheating'
with the types and the content, which I would not like to allow.
This is why I stick to the original approach of having the Messages handled internally 
by the world, not in the user code.

API - World
I have to use more telling names. The API in fact the "world" that you can reach through
the available functions. So, the API is dustWorld from now on: the world is the active
and communicating entity set invoked from the persistent storages, play their roles and
get dismissed again, on a single running environment. The attributes of this world are
the deployment configuration information.
There is another level, the dustUniverse, which are the worlds connected to each other.
A world knows about a portion of this universe, and this knowledge is extended by new 
types: like the "Person" type is hosted on big public servers; when I have to get a Person,
my world gets the type declaration which contains the link to this other world, extending
my knowledge about the dust Universe.     